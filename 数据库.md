# 数据库

## 关系数据库

域：是一组具有相同数据类型的值得集合。

笛卡尔积：是域上得一种集合运算。

码：

- 若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码

- 关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）

- 若一个关系有多个候选码，则选定其中一个为主码（Primary key）

- 候选码的诸属性称为主属性（Prime attribute）

- 不包含在任何侯选码中的属性称为非主属性（ Non-Prime attribute）

  或非码属性（Non-key attribute） 

关系操作

- 查询：选择、投影、连接、除、并、交、差
- 数据更新：插入、删除、修改
- 查询的表达能力是其中最主要的部分
- 选择、投影、并、差、笛卡尔基是5种基本操作

关系的三类完整性约束：

1. 实体完整性：若属性*A*是基本关系*R*的主属性，则属性*A*不能取空值
2. 参照完整性：对于永久关系的相关表，在更新、插入或删除记录时，如果只改其一，就会影响数据的完整性。如删除父表的某记录后，子表的相应记录未删除，致使这些记录称为孤立记录。对于更新、插入或删除表间数据的完整性。设*F*是基本关系*R*的一个或一组属性，但不是关系*R*的码。如果F与基本关系*S*的主码Ks相对应，则称F是基本关系*R*的外码
3. 用户定义的完整性

关系代数

 传统的集合运算：并，差，交，笛卡尔积

 专门的关系运算：选择，投影，连接，除

### SQL(结构化查询语言)

#### 特点：

- 综合统一
- 高度非过程化
- 面向集合的操作方式
- 以同一种语法结构提供多种使用方式
- 语言简洁，易学易用

文件：主数据文件，辅助数据文件和日志文件

DROP TABLE <表名>［RESTRICT| CASCADE］；

RESTRICT：删除表是有限制的。

CASCADE：删除该表没有限制。

建立索引的目的：加快查询速度

索引一般采用B+树、HASH索引来实现：

- B+树索引具有动态平衡的优点

- HASH索引具有查找速度快的特点

索引是唯一索引、非唯一索引或聚簇索引。

在最经常查询的列上建立聚簇索引以提高查询效率，一个基本表上最多只能建立一个聚簇索引，经常更新的列不宜建立聚簇索引 

### 数据查询

语句格式

​    SELECT [ALL|DISTINCT] <目标列表达式>

​                        [，<目标列表达式>] …

​	FROM <表名或视图名>[， <表名或视图名> ] …

​	[ WHERE <条件表达式> ]

​	[ GROUP BY <列名1> [ HAVING <条件表达式> ] ]

​	[ ORDER BY <列名2> [ ASC|DESC ] ]；

DISTINCT：消除取值重复的行

确定集合：IN <值表>, NOT IN <值表>     

字符匹配：LIKE
 ESCAPE '＼' 表示“ ＼” 为换码字符

涉及空值的查询: IS NULL或IS NOT NULL

ORDER BY子句:

可以按一个或多个属性列排序

升序：ASC；降序：DESC；缺省值为升序

聚集函数：

计数

COUNT（[DISTINCT|ALL] *）

COUNT（[DISTINCT|ALL] <列名>）

计算总和

SUM（[DISTINCT|ALL] <列名>） 

计算平均值

AVG（[DISTINCT|ALL] <列名>）

最大最小值

  MAX（[DISTINCT|ALL] <列名>）

  MIN（[DISTINCT|ALL] <列名>）

GROUP BY子句分组：

细化聚集函数的作用对象

未对查询结果分组，聚集函数将作用于整个查询结果

对查询结果分组后，聚集函数将分别作用于每个组 

作用对象是查询的中间结果表

按指定的一列或多列值分组，值相等的为一组

- 有group by时，select 和 having子句中出现的属性有所限制。
- 任何出现在having子句中，但没有被聚集的属性必须出现在group by子句中。

WHERE子句作用于基表或视图，从中选择满足条件的元组

HAVING短语作用于组，从中选择满足条件的组。

#### 嵌套查询

将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询。

子查询的限制：不能使用ORDER BY

 一、带有IN谓词的子查询 

 二、 带有比较运算符的子查询

 三、 带有ANY（SOME）或ALL谓词的子查询

 四、 带有EXISTS谓词的子查询

#### 集合查询

集合操作的种类：

- 并操作UNION
- 交操作INTERSECT
- 差操作EXCEPT

参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同 

UNION：将多个查询结果合并起来时，系统自动去掉重复元组。

UNION ALL：将多个查询结果合并起来时，保留重复元组 

### 视图

虚表，是从一个或几个基本表（或视图）导出的表，只存放视图的定义，不存放视图对应的数据，基表中的数据发生变化，从视图中查询出的数据也随之改变。

## 数据库安全

数据库安全性控制的常用方法：

- 用户标识和鉴别
- 存取控制
- 视图
- 审计
- 密码存储

授权与回收：GRANT和REVOKE

## 关系数据理论

若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或 “Y函数依赖于X”，记作X→Y。 

在R(U)中，如果X→Y，并且对于X的任何一个真子集X’，都有X’   Y, 则称Y对X完全函数依赖。若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖

事务的四大特性(ACID)

原子性(Atomicity):事务是一个完整的操作，事务的各步操作时不可分的(原子的);要么都执行，要么都不执行。
一致性(Consistency):当事务完成时，数据必须处于一致状态。
隔离性(Isolation):对数据进行修改的所有并发事务是彼此隔离的，这表明事务必须是独立的，它不应以任何方式依赖与或影响其他事务。
持久性(Durability):事务完成后，它对数据库的修改被永久保持，事务日志能够保持事务的永久性。

## 并发控制

并发控制的主要技术

- 封锁(Locking)
- 时间戳(Timestamp)
- 乐观控制法

封锁就是事务T在对某个数据对象（例如表、记录等）操作之前，先向系统发出请求，对其加锁,加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

基本封锁类型:

排它锁（Exclusive Locks，简记为X锁）

共享锁（Share Locks，简记为S锁）

排它锁又称为写锁

若事务T对数据对象A加上X锁，则只允许T读取和修改A，其它任何事务都不能再对A加任何类型的锁，直到T释放A上的锁,保证其他事务在T释放A上的锁之前不能再读取和修改A

共享锁又称为读锁

若事务T对数据对象A加上S锁，则其它事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁,保证其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

避免活锁：采用先来先服务的策略

解决死锁：

- 预防死锁：破环产生死锁的条件。
- 死锁的诊断和解除

**预防死锁的方法**：

- **一次封锁法**
- **顺序封锁法**

**死锁的诊断**：

- **超时法**
- **事务等待图法**

**解除死锁**：

- **选择一个处理死锁代价最小的事务，将其撤消**
- **释放此事务持有的所有的锁，使其它事务能继续运行下去**

**两段锁协议**：**指所有事务必须分两个阶段对数据项加锁和解锁**

**在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁**， **在释放一个封锁之后，事务不再申请和获得任何其他封锁**

**封锁对象的大小称为封锁粒度**

**显式封锁:** **直接加到数据对象上的封锁**

**隐式封锁**: **该数据对象没有独立加锁，是由于其上级结点加锁而使该数据对象加上了锁**

