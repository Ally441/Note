# 微服务容器化开发实战



#### 单体架构

###### 单体架构的特点

1. 所有功能集中在一个工程项目中。
2. 所有功能打包成一个war文件或jar文件
3. 通过部署应用集群进行应用扩容以提高性能

###### 单体架构的优点

1. 项目架构简单
2. 前期开发成本低，周期短
3. 部署简单

###### 单体架构的缺点

开发效率低，代码维护难，部署不灵活，稳定性不高，扩展性不足

#### 微服务架构

###### 微服务架构的特点：微小、独立、轻量、松耦合

1. 系统服务层拆分抽取为一个一个的微服务
2. 遵循单一功能原则
3. 微服务之间采用RESTful等轻量级协议进行通信

###### 微服务架构的优点：

开发简单，开发快捷，技术栈灵活，服务独立无依赖，独立按需扩展，可用性高

###### 微服务架构的缺点：

1. 多服务运维难度大幅度提升
2. 系统部署依赖度提高，服务治理成本增加
3. 服务间通信成本增加
4. 数据一致性挑战难度增加
5. 技术成本高，团队挑战难度增加

前后端分离分为逻辑分离和物理分离。

逻辑分离和物理分离都在业务逻辑和功能发布上划分上做到代码结构上分离，但逻辑分离在程序打包发布时一起发布，物理分离做到了可以独立打包和独立部署。

#### 微服务设计原则

###### AKF拆分原则

![1](C:\Users\Ally\Desktop\note\1.png)

Y轴（功能）关注应用中功能划分，基于不同的业务拆分

X轴（水平扩展）关注水平扩展，也就是“加速器解决问题“

Z轴（数据分区）关注服务与数据的优先级划分，如按地域划分

###### 前后端完全分离原则

###### 无状态服务原则

如果一个数据需要被多个服务共享，才能完成一笔交易，那么这个数据被称为状态。进而依赖这个状态的服务被称为有状态的服务，反之成为无状态服务。把有状态的业务服务改变为无状态的计算类服务，那么状态数据也就相应的迁移到对应的“有状态数据服务”中。

###### RESTful通信风格

#### 微服务拆分原则

1. ###### 粒度适中原则

2. ###### 先大后小原则

3. ###### 公共服务抽取原则

4. ###### 实体类封装原则

#### 微服务命名

采用三段式的命名规则，如xxxx-xxxx-xxxx形式，全都是小写，单词之间不能有空格和下划线

版本配置： 如application-dev.yml 开发，可以在微服务启动时可以动态传入参数为”--spring.profiles.active=test“，dev ： 开发 	test: 测试 	grey:灰度（准生产）	prod:生产   

#### 微服务框架

###### Dubbo 和 SpringCloud

Dubbo主要提供三大核心能力：

1. 面向接口的远程方法调用
2. 智能容错和负载均衡
3. 服务自动注册和发现

![img](file:///C:\Users\Ally\Documents\Tencent Files\2443781337\Image\C2C\F8A93DF55F596C0EFB16134D6CA5F96B.jpg)

模块说明：

1. Provider:暴露服务的提供者
2. Consumer:调用远程服务的消费者
3. Registry:服务注册与发现的注册中心
4. Monitor:统计服务的调用次数和调用时间的监控中心
5. Container:服务的运行容器

![img](file:///C:\Users\Ally\Documents\Tencent Files\2443781337\Image\C2C\ED82DF4FEA394995781056D309FC8AF0.jpg)

 

SpringCloud主要包括EUREKA、Zuul、CONFIG SERVICE、Hystrix Dashboard、Turbine等组件（负载均衡组件Ribbon内嵌在服务调用中）

1. EUREKA:服务注册与发现的注册中心
2. Zuul:网关和路由
3. CONFIG SERVICE:分布式配置服务
4. Hystrix Dashboard： 服务熔断监控组件
5. Turbine：服务调用汇集展示

maven打包命令：

不带参数：mvn clean package

带参数：mvn clean package -DskipTests=true

运行命令： java -jar xxx-xxx-xxx-1.0.0-SNAPSHOT.jar --spring.profiles.active=dev

